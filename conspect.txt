Init ts project: tsc --init. We will get tsconfig file. tsc command compiles ts files into js.

Tuple: [number, string]. Allow push and pop operation. Interesting exaple: const arr: [number, string, ...boolean[]] = [1, 'aaa', true, false]

Readonly: const arr: readonly string[] = [1,2,3]. demand ellements changing before compilation and push, pop operations.

Type narrowing: 
const obj: { a: string } | { b: string } = { a: 'AA' }
if (a in obj) {
  console.log(obj.a);
} else {
  console.log(obj.b);
}
Another one:
const a: number | string = 'gg';
if (typeof a === 'number') {
  console.log(a.toString());
} else {
  console.log(a.length);
}

Literal types: when a variable can have only exact meaning. E.g. const a = 1; (a: 1); With union types: function f(gg: 'post' | 'get'). E.g.: 
function f(gg: 'post' | 'get')
let v = 'post';
f(v) - recieve comple error, because gg - literal type but v - string. To fix it we have two ways: 1. const v = 'post' - literal type in this case. 2. f(v as 'post')

type: 
type strNumber = number | string;
type Person = {
  age: number,
  name: string
}
type Role = {
  isAdmin: boolean,
  role: string
}
type User = Person & Role;
const person: Person = {
  age: 23,
  name: 'Ivan',
  isAdmin: true,
  role: 'God'
}

interfaces:
interface Person {
  name,
  age
}
interface Role {
  id: number
}
interface User extends Person, Role {
  isValid: (action: string) => boolean;
}

types or interfaces
E.g.
interface User {
  age: number;
}
interface User {
  name: string;
}
const user: User = {
  age: 23,
  name: 'Ivan'
}
With types you can not do such things.
Types are usually used for union primitive type. Interfaces for classes and objects.

Optional types
interface User {
  name: string;
  password?: string //is optional. Different from password: string | undefined !!!
}
password ?? 'hello' the same if (password === null | password === undefined) return hello esle return password;
password! - shows compiler that password 100% is not undefined

Void
Function return nothing. If function declaired like void returns something, ts will ignore it and you will not be able to variable that recieve value from void func.
Provides compatibility

Unknown
Can be assigned only to unknown or any type of variable. Can be met in errors when we use try/catch. To use unknown variable it is nessasarry to use type narrowing. 
Example with type operator: type U1 = unknown | string - always unknown despite string.
type U2 = unknown & string; - always string

Never
Shows that actions should never happend. 
Helps to write more safety code. 
Examples of using:
1. Functions that return errors: function throwErr(): never { throw new Error() }
2. infinite cycles and recursions.
3. in switch/case constructions(to say about error during type extensions)
void can return never and we can assign undefined to void variable. never - will never return

Null
Can be assigned only to null or any. Use null when we should consciously say that object or variable is not defined.

Type Guards
Example: 
function(v: string | number): v is string {
  if (typeof v === 'string') {
    return true;
  } else {
    return false;
  }
}
Can be used for type narrowing


Assert
Example:
interface User {
  name: string;
}
function assertUser(obj: unknown): assert obj is User {
  if (typeof obj === 'object' && !!obj && 'name' in User) {
    return;
  } else {
    throw new Error();
  }
}
a = {}
assertUser(a);
console.log(a.name); // no compildation errors cause we have used assert function

Overwrite
function foo(a: number);
function foo(a: string);
function foo(a: number | string) {
  console.log(a);
}
Can be use for constractor too. Constructor always returns instance of class object. Return can not be overwritten.

Implements
Usually, obviosly, but some not standart examples. 
interface IUser {
  foo(name: string): void;
}
class User implements IUser {
  async foo(name: string | number): Promise<void> {
    console.log(name);
}
This example is correct. Compiler will not show any errors.

Extendes
When we inherit, we should notice parent's constructor using super. We also can call parent's methods in child's class, e.g. super.pay(). And we should write overwrite word in child's class when overwrite methods.

Features of inheritance
Example
class User {
  name: string = 'user';

  constructor() {
    console.log(this.name);
  }
}
class Admin {
  name: string = 'admin';
}
new Admin();
Shows "user", but 

class User {
    name: string = 'user';

    constructor() {
        console.log(this.name);
    }
}
class Admin extends User {
    name: string = 'admin';

    constructor() {
        super();
        console.log(this.name);
    }
}
new Admin();
shows:
"user"
"admin"

We can use inheritance effectively when we have the same domain area. For example, when we have user and we want to make UserWithCreds class. But it will be a bad idea when we have different domain areas. E.g., Paymnet and UserWithPayment. In this case the best way is a composition:
class Payment {
  paymentId: string;
}
class User {
  name: string;
}
class UserWithPayment {
  payment: Payment;
  user: User;
}

Privacy in ts and js
Example
class User {
  private a: string = 'aa';
  #b = 'bb'; //private method from js. Uses WeakMap() under the hood
}
const u = new User();
console.log(u.a) //should be compile error, but print aa
console.log(u.b) //should be compile error, but print undefined not bb


Static properties
class User {
  static gg: string;
  static async db(id: string): Promise<void> {
    console.log(id, User.gg);
  }

  static {
    //can be only sync
    User.gg = 'abc';
  }
}

This
In class properties we can use e.g. 
class Payment {
  date: Date;
  setDate(this: Payment) { //can hint to compiler about context to not lo 
    this.date = new Date()
  }
}
To fix context we can use arrow functions
This can be used as property type:
class UserBuilder {
  name: string;
  setName(name: string): this {
    this.name = name;
    return this;
  }
}

Abstract classes
abstract class AA {
  public abstract method(): void; // реализация недопустима
  public method2(): string {
    return 'str';
  }
}
const a = new AA(); //error. Only can be extended

Compiler structure
Структура Компилятора TypeScript
Core TypeScript Compiler
-Содержит основные библиотеки для компиляции TypeScript в JavaScript.
 Описывает процесс и логику компиляции.
TSC (TypeScript Compiler CLI)
-CLI утилита для вызова компилятора.
 Использует настройки файла или конфигурации для компиляции.
LanguageService
- Отвечает за логику работы с языком TypeScript.
TSServer
-Интерфейс для IDE и текстовых редакторов.
-Подключается к IDE, например, VSCode, для работы с проектом TypeScript.

TypeScript поддерживает компиляцию файлов через tsconfig.json или напрямую через командную строку.
Компиляция через командную строку:
Используйте утилиту tsc для компиляции отдельных файлов.
Пример: tsc app2.tsc компилирует файл app2.tsc в JavaScript.
Для компиляции всего проекта используйте tsc без указания файлов. При наличии файла tsconfig.json будут использованы его настройки.
Настройки компиляции в tsconfig.json:
Files: Указывает конкретные файлы для компиляции.
Пример: {"files": ["app.ts"]} компилирует только файл app.ts.
Include и Exclude: Используются для более гибкого выбора файлов.
Include поддерживает паттерны и позволяет выбирать группы файлов.
Пример: "include": ["app*.ts"] включает все файлы, начинающиеся на app.
Exclude исключает файлы из компиляции.
Пример: "exclude": ["app.ts"] исключает файл app.ts из компиляции.
Extends: Позволяет наследовать настройки из другого tsconfig.json.
Пример: "extends": "./base/tsconfig.json" наследует настройки из файла base/tsconfig.json.
allowJs и checkJs: Позволяют включать и проверять JavaScript файлы в проекте TypeScript.
allowJs: включает JS файлы в компиляцию.
checkJs: включает проверку JS файлов TypeScript компилятором.

Compilation Output
Введение в emit:
Объяснение понятия и переход от выбора файлов к их преобразованию.
Примеры с outDir и outFile для управления местоположением и формой итоговых файлов.
Параметры emit:
outDir: перенаправляет итоговые JavaScript-файлы в указанную директорию.
outFile: используется преимущественно с модулями AMD для объединения итоговых файлов в один.
noEmit, noEmitOnError, noEmitHelpers: управление эмитированием файлов в случаях ошибок или для определенных helper-функций.
removeComments: удаляет комментарии из итогового JS-кода.
Работа с Source Maps:
Описание utility source maps для связи между исходным TS и итоговым JS кодом.
inlineSourceMap и inlineSources: встраивание source maps и исходного кода непосредственно в итоговые JS-файлы.
Генерация деклараций (.d.ts файлов):
Важность этих файлов для описания типов и структур TS в JS проектах.
Использование declaration, declarationDir, declarationMap для управления генерацией и местоположением деклараций.
declarationOnly для создания чисто декларативных пакетов.
Управление компиляцией:
stripInternal: исключение некоторых внутренних типов из деклараций.
preserveConstEnums: сохранение const enums как объектов вместо инлайновых значений.

Target section in compiler
1. Выбор целевой платформы (Target):
ECMAScript версии от 2016 до 2022.
Зависит от среды запуска (браузер, Node.js) и требуемой совместимости.
2. Встроенные API и библиотеки (Lib):
По умолчанию доступны Web API (напр. Console, Math).
Возможность исключить или добавить библиотеки, например, для работы с DOM.
В NODE.js можно отключить поддержку DOM.
Использование Polyfill для расширения функционала в зависимости от версии ECMAScript.
3. Работа с JSX (для React):
Конфигурирование компиляции JSX (Preserve, React JSX, React Native).
Указание методов создания JSX элементов и фрагментов.
Отказ от использования стандартных библиотек (NoLib True) для минимизации бандла.
4. Декораторы:
Экспериментальная поддержка.
Настройка обработки декораторов.

Module section in compiler
Основы модульности:

Важность модульности для организации кода.
В Node.js часто используется CommonJS (через require и exports).
Во frontend и в современном Node.js применяются ES6 модули (import и export).
TypeScript и ES модули только начинают полноценно поддерживаться в Node.js.
Настройка проекта с использованием модулей:

Модули:
Возможность использования различных систем модулей: CommonJS для backend и ES6 для frontend.
Редко используемые типы: AMD, System, UMD.
Root директория:
Определение корневой директории проекта.
Пример разделения кода и типов в разные директории для предотвращения конфликтов.
Base URL и пути:
Установка базового URL для резолвинга модулей.
Использование алиасов для упрощения импортов, особенно в больших проектах или монорепозиториях.

Strict section in compiler
Введение в Strict Mode:
Strict Mode - это режим в TypeScript, который задействует более строгую проверку типов в коде.
Включается опцией strict: true в tsconfig, активируя набор дополнительных правил проверки.
Ключевые опции Strict Mode:
No Implicit Any: Предотвращает неявное присвоение типа any переменным, требуя явного указания типов.
Strict Null Checks: Обязывает разработчика учитывать значения null и undefined, избегая потенциальных ошибок при обращении к переменным.
Strict Function Types: Усиливает проверку типов для параметров и возвращаемых значений функций, предотвращая недопустимые присваивания.
Bind, Call, Apply Checks: Улучшает контроль за передачей аргументов в эти функции, позволяя избежать ошибок в их использовании.
Strict Property Initialization: Требует явной инициализации свойств классов, уменьшая риск работы с неинициализированными свойствами.
No Implicit This: Помогает избежать ошибок связанных с потерей контекста this в методах классов.
Use Unknown Instead of Any in Catch: Требует обработки переменных catch как unknown, уменьшая риск необработанных исключений.
Always Strict: Применяет strict mode в JavaScript, дополнительно усиливая проверки в рантайме.
Рекомендации По Использованию:
Всегда включайте strict: true в новых проектах для обеспечения лучшего контроля типов и предотвращения типичных ошибок.
При возникновении конфликтов с определенной опцией строгого режима, предпочтительно настраивать её поточечно, вместо отключения всего режима строгости.
В случае миграции существующего проекта на TypeScript, начните с постепенного перехода, активируя строгие проверки по мере исправления и доработки кода.

Code checking
В этом видео мы обсудим настройки в TypeScript, которые не являются строгими настройками (strict), но могут существенно улучшить качество вашего кода.
Основные Настройки
No Unused Locals
Убирает неиспользованные локальные переменные, позволяя избежать мусора в коде.
Используйте @ts-ignore для игнорирования предупреждений в редких необходимых случаях.
No Unused Parameters
Аналогично предыдущему, но для параметров функций.
Exact Optional Property Types
Требует явного задания значений для необязательных свойств, предотвращая присвоение undefined без необходимости.
No Fall Through Cases in Switch
Предотвращает случайное "проваливание" между кейсами в switch без break или return.
Unreachable Code
Определяет и сообщает о коде, выполнение которого невозможно.
NoUnchecked Indexed Access
Добавляет undefined к типу возвращаемого значения при обращении к свойствам объекта, у которого индекс не является точно заданным.
Implicit Override
Требует использования ключевого слова override при переопределении методов в дочерних классах.
Дополнительные Настройки
Skip Lib Check & Skip Default Lib Check
Позволяют пропустить проверку типов в библиотеках и дефолтных библиотеках, что может ускорить компиляцию.

Generics
built-in generics examples:
1) const a: Array<number> = [1, 2, 3];
2) async function foo() {
  const r = await new Promise<number>(res => {
    res(123);
  });
3) const check: Record<string, boolean> = {
  drive: true,
  kpp: false
}

Generics in function 
Example:
function logger<T>(data: T): T {
  console.log(data);
  return data;
}
const a = logger<number>(123);
function getSplitedArray<T>(arr: Array<T>): Array<T> {
  const l = arr.length // 2;
  return arr.splice(0, l);
}

Generics in types and interfaces
Examples:
interface IMyInterface<T> {
  name: string;
  smth: T;
}
type MyType<T> = {
  name: string;
  smth: T;
}

Generics in classes
class Res<D, E> {
  data: D;
  error: E;

  constructor(data?: D, error?: E) {
    if (data) {
      this.data = data;
    }
    if (error) {
      this.error = error;
    }
  }
}

Mixins
...

Keyof
Оператор keyof в TypeScript позволяет извлекать ключи из интерфейсов, классов или объектов.
Это полезно для создания типов, которые могут принимать только существующие ключи объекта или интерфейса.
Пример использования:
Допустим, есть интерфейс IUser с полями name и age.
Мы можем создать тип CaseOfUser используя keyof IUser, который будет равен типу "name" | "age", ограничивая значения только ключами IUser.
Практическое применение:
Функция возврата значения по ключу:
Можно реализовать функцию getValue, которая принимает объект и ключ, а возвращает значение соответствующего ключа объекта.
Типизация:
Для точной типизации функции getValue используется generic тип T для объекта и K для ключа.
Ключ K ограничивается keyof T, гарантируя, что ключ действительно существует в объекте T.
Пример функции getValue:
function getValue<T, K extends keyof T>(object: T, key: K): T[K] {
  return object[key];
}
Это обеспечивает, что код безопасен в runtime: если попытаться использовать несуществующий ключ, TypeScript выдаст ошибку на этапе компиляции.

typeof
Example
let strOrNumber: string | number;
let strOrNumber2: typeof strOrNumber;
const user = {
  name: "Ivan",
  age: 100
}
let u2: keyof typeof user //let u2: "name" | "age"
let u3: keyof user; //Error: 'user' refers to a value, but is being used as a type here. Did you mean 'typeof user'?

Indexed Access Types
Examples:
interface Role {
  name: string;
}
interface User {
  name: string;
  roles: Role[];
}
type type1 =  User['roles'];//type1 = Role[]
//But next exp gives an error
const roles: string = 'roles'
type type2 =  User[roles] //'roles' refers to a value, but is being used as a type here;
//We can fix it
const roles2 = 'roles';
type type3 = User[typeof roles2];
//To get Role type from array
type RoleType = User["roles"][number]; //RoleType = Role
//Another useful example
const rolesArray = ['admin', 'user'] as const; // type = readonly ['admin', 'user']
type RoleTypes = typeof rolesArray[number]; //type RoleTypes = "admin" | "user"

Conditional Types
interface HTTPResponse<T extends 'success' | 'failed'> {
  code: number;
  data: T extends 'success' ? string : Error;
}
const err: HTTPResponse<'failed'> = {
  code: 500,
  data: new Error('failed')
}
  
Infer
...

Mapped Types
...

Liretal Template Types
...

Partial, Required, Readonly
examples
interface User {
  name: string;
  age?: number;
}
type R = Readonly<User>;
/*
type Read = {
    readonly name: string;
    readonly age?: number | undefined;
}
We can not change readonly property after object creation
*/
type Req = Required<User>;
/*
type Req = {
    name: string;
    age: number;
}
*/
type Par = Partial<User>;
/*
type Par = {
    name?: string;
    age?: number;
}
*/

Pick, Omit, Extract, Exclude
interface User {
  name: string;
  skills: string;
  age: number;
}
type o = Omit<User, 'name' | 'skills'>;
/*
type o = {
  age: number;
}
*/
type p = Pick<User, 'name' | 'skills'>;
/*
type p = {
  name: string;
  skills: string;
}
*/
type extr = Extract<User | string, string>; //type extr = string;
type excl = Exclude<User | string | boolean, User>; //type excl = string | boolean;

