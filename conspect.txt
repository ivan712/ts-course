Init ts project: tsc --init. We will get tsconfig file. tsc command compiles ts files into js.

Tuple: [number, string]. Allow push and pop operation. Interesting exaple: const arr: [number, string, ...boolean[]] = [1, 'aaa', true, false]

Readonly: const arr: readonly string[] = [1,2,3]. demand ellements changing before compilation and push, pop operations.

Type narrowing: 
const obj: { a: string } | { b: string } = { a: 'AA' }
if (a in obj) {
  console.log(obj.a);
} else {
  console.log(obj.b);
}
Another one:
const a: number | string = 'gg';
if (typeof a === 'number') {
  console.log(a.toString());
} else {
  console.log(a.length);
}

Literal types: when a variable can have only exact meaning. E.g. const a = 1; (a: 1); With union types: function f(gg: 'post' | 'get'). E.g.: 
function f(gg: 'post' | 'get')
let v = 'post';
f(v) - recieve comple error, because gg - literal type but v - string. To fix it we have two ways: 1. const v = 'post' - literal type in this case. 2. f(v as 'post')

type: 
type strNumber = number | string;
type Person = {
  age: number,
  name: string
}
type Role = {
  isAdmin: boolean,
  role: string
}
type User = Person & Role;
const person: Person = {
  age: 23,
  name: 'Ivan',
  isAdmin: true,
  role: 'God'
}

interfaces:
interface Person {
  name,
  age
}
interface Role {
  id: number
}
interface User extends Person, Role {
  isValid: (action: string) => boolean;
}

types or interfaces
E.g.
interface User {
  age: number;
}
interface User {
  name: string;
}
const user: User = {
  age: 23,
  name: 'Ivan'
}
With types you can not do such things.
Types are usually used for union primitive type. Interfaces for classes and objects.

Optional types
interface User {
  name: string;
  password?: string //is optional. Different from password: string | undefined !!!
}
password ?? 'hello' the same if (password === null | password === undefined) return hello esle return password;
password! - shows compiler that password 100% is not undefined

Void
Function return nothing. If function declaired like void returns something, ts will ignore it and you will not be able to variable that recieve value from void func.
Provides compatibility

Unknown
Can be assigned only to unknown or any type of variable. Can be met in errors when we use try/catch. To use unknown variable it is nessasarry to use type narrowing. 
Example with type operator: type U1 = unknown | string - always unknown despite string.
type U2 = unknown & string; - always string

Never
Shows that actions should never happend. 
Helps to write more safety code. 
Examples of using:
1. Functions that return errors: function throwErr(): never { throw new Error() }
2. infinite cycles and recursions.
3. in switch/case constructions(to say about error during type extensions)
void can return never and we can assign undefined to void variable. never - will never return

Null
Can be assigned only to null or any. Use null when we should consciously say that object or variable is not defined.

Type Guards
Example: 
function(v: string | number): v is string {
  if (typeof v === 'string') {
    return true;
  } else {
    return false;
  }
}
Can be used for type narrowing


Assert
Example:
interface User {
  name: string;
}
function assertUser(obj: unknown): assert obj is User {
  if (typeof obj === 'object' && !!obj && 'name' in User) {
    return;
  } else {
    throw new Error();
  }
}
a = {}
assertUser(a);
console.log(a.name); // no compildation errors cause we have used assert function
