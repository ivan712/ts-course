Init ts project: tsc --init. We will get tsconfig file. tsc command compiles ts files into js.

Tuple: [number, string]. Allow push and pop operation. Interesting exaple: const arr: [number, string, ...boolean[]] = [1, 'aaa', true, false]

Readonly: const arr: readonly string[] = [1,2,3]. demand ellements changing before compilation and push, pop operations.

Type narrowing: 
const obj: { a: string } | { b: string } = { a: 'AA' }
if (a in obj) {
  console.log(obj.a);
} else {
  console.log(obj.b);
}
Another one:
const a: number | string = 'gg';
if (typeof a === 'number') {
  console.log(a.toString());
} else {
  console.log(a.length);
}

Literal types: when a variable can have only exact meaning. E.g. const a = 1; (a: 1); With union types: function f(gg: 'post' | 'get'). E.g.: 
function f(gg: 'post' | 'get')
let v = 'post';
f(v) - recieve comple error, because gg - literal type but v - string. To fix it we have two ways: 1. const v = 'post' - literal type in this case. 2. f(v as 'post')

type: 
type strNumber = number | string;
type Person = {
  age: number,
  name: string
}
type Role = {
  isAdmin: boolean,
  role: string
}
type User = Person & Role;
const person: Person = {
  age: 23,
  name: 'Ivan',
  isAdmin: true,
  role: 'God'
}

interfaces:
interface Person {
  name,
  age
}
interface Role {
  id: number
}
interface User extends Person, Role {
  isValid: (action: string) => boolean;
}

types or interfaces
E.g.
interface User {
  age: number;
}
interface User {
  name: string;
}
const user: User = {
  age: 23,
  name: 'Ivan'
}
With types you can not do such things.
Types are usually used for union primitive type. Interfaces for classes and objects.

Optional types
interface User {
  name: string;
  password?: string //is optional. Different from password: string | undefined !!!
}
password ?? 'hello' the same if (password === null | password === undefined) return hello esle return password;
password! - shows compiler that password 100% is not undefined

Void
Function return nothing. If function declaired like void returns something, ts will ignore it and you will not be able to variable that recieve value from void func.
Provides compatibility

Unknown
Can be assigned only to unknown or any type of variable. Can be met in errors when we use try/catch. To use unknown variable it is nessasarry to use type narrowing. 
Example with type operator: type U1 = unknown | string - always unknown despite string.
type U2 = unknown & string; - always string

Never
Shows that actions should never happend. 
Helps to write more safety code. 
Examples of using:
1. Functions that return errors: function throwErr(): never { throw new Error() }
2. infinite cycles and recursions.
3. in switch/case constructions(to say about error during type extensions)
void can return never and we can assign undefined to void variable. never - will never return

Null
Can be assigned only to null or any. Use null when we should consciously say that object or variable is not defined.

Type Guards
Example: 
function(v: string | number): v is string {
  if (typeof v === 'string') {
    return true;
  } else {
    return false;
  }
}
Can be used for type narrowing


Assert
Example:
interface User {
  name: string;
}
function assertUser(obj: unknown): assert obj is User {
  if (typeof obj === 'object' && !!obj && 'name' in User) {
    return;
  } else {
    throw new Error();
  }
}
a = {}
assertUser(a);
console.log(a.name); // no compildation errors cause we have used assert function

Overwrite
function foo(a: number);
function foo(a: string);
function foo(a: number | string) {
  console.log(a);
}
Can be use for constractor too. Constructor always returns instance of class object. Return can not be overwritten.

Implements
Usually, obviosly, but some not standart examples. 
interface IUser {
  foo(name: string): void;
}
class User implements IUser {
  async foo(name: string | number): Promise<void> {
    console.log(name);
}
This example is correct. Compiler will not show any errors.

Extendes
When we inherit, we should notice parent's constructor using super. We also can call parent's methods in child's class, e.g. super.pay(). And we should write overwrite word in child's class when overwrite methods.

Features of inheritance
Example
class User {
  name: string = 'user';

  constructor() {
    console.log(this.name);
  }
}
class Admin {
  name: string = 'admin';
}
new Admin();
Shows "user", but 

class User {
    name: string = 'user';

    constructor() {
        console.log(this.name);
    }
}
class Admin extends User {
    name: string = 'admin';

    constructor() {
        super();
        console.log(this.name);
    }
}
new Admin();
shows:
"user"
"admin"

We can use inheritance effectively when we have the same domain area. For example, when we have user and we want to make UserWithCreds class. But it will be a bad idea when we have different domain areas. E.g., Paymnet and UserWithPayment. In this case the best way is a composition:
class Payment {
  paymentId: string;
}
class User {
  name: string;
}
class UserWithPayment {
  payment: Payment;
  user: User;
}

Privacy in ts and js
Example
class User {
  private a: string = 'aa';
  #b = 'bb'; //private method from js. Uses WeakMap() under the hood
}
const u = new User();
console.log(u.a) //should be compile error, but print aa
console.log(u.b) //should be compile error, but print undefined not bb


Static properties
class User {
  static gg: string;
  static async db(id: string): Promise<void> {
    console.log(id, User.gg);
  }

  static {
    //can be only sync
    User.gg = 'abc';
  }
}

This
In class properties we can use e.g. 
class Payment {
  date: Date;
  setDate(this: Payment) { //can hint to compiler about context to not lo 
    this.date = new Date()
  }
}
To fix context we can use arrow functions
This can be used as property type:
class UserBuilder {
  name: string;
  setName(name: string): this {
    this.name = name;
    return this;
  }
}

Abstract classes
abstract class AA {
  public abstract method(): void; // реализация недопустима
  public method2(): string {
    return 'str';
  }
}
const a = new AA(); //error. Only can be extended
